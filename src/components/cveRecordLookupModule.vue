<template>
  <div class="field mt-1" style="">
    <div class="field has-addons mb-1">
      <div class="control is-expanded">
        <input v-model="cveId" @keyup.enter="lookupId" @keyup="validateCveId" class="input" type="text"
          placeholder="Enter CVE ID (e.g.: CVE-YYYY-NNNN...)"/>
      </div>
      <div class="control">
        <button class="button cve-button cve-button-accent-warm" :class="{'is-loading': this.$store.state.isSearching}" @click="lookupId"
          :disabled="disabled">
          Find
        </button>
      </div>
    </div>
    <div class="notification is-warning" role="alert" v-if="errorMessage.length > 0">
      <div class="is-flex" style="justify-content: flex-start;">
        <p id="alertIcon" class="is-hidden">alert</p>
        <font-awesome-icon style="flex: 0 0 40px; margin-top:3px" size="1x"  icon="exclamation-triangle" role="alert"
          aria-labelledby="alertIcon" aria-hidden="false" />
        <p class="cve-help-text" v-for="errorMsg in errorMessage" :key="errorMsg.key">{{errorMsg}}</p>
      </div>
    </div>
  </div>
</template>

<script>
import axios from 'axios';

export default ({
  data() {
    return {
      cveId: this.$store.state.cveId,
      showHelpText: false,
      errorMessage: [],
      disabled: true,
      records: [
        {
          data_type: 'CVE',
          data_format: 'MITRE',
          data_version: '4.0',
          CVE_data_meta: {
            ID: 'CVE-2020-19045',
            ASSIGNER: 'cve@mitre.org',
            STATE: 'RESERVED',
          },
          description: {
            description_data: [
              {
                lang: 'eng',
                value: '** RESERVED ** This candidate has been reserved by an organization or individual that will use it when announcing a new'
                + 'security problem. When the candidate has been publicized, the details for this candidate will be provided.',
              },
            ],
          },
        },
        {
          CVE_data_meta: {
            ASSIGNER: 'cve@mitre.org',
            ID: 'CVE-2020-13644',
            STATE: 'PUBLIC',
            UPDATED: '2021-07-23',
          },
          affects: {
            vendor: {
              vendor_data: [
                {
                  product: {
                    product_data: [
                      {
                        product_name: 'n/a',
                        version: {
                          version_data: [
                            {
                              version_value: 'n/a',
                            },
                          ],
                        },
                      },
                    ],
                  },
                  vendor_name: 'n/a',
                },
              ],
            },
          },
          data_format: 'MITRE',
          data_type: 'CVE',
          data_version: '4.0',
          description: {
            description_data: [
              {
                lang: 'eng',
                value: 'An issue was discovered in the Accordion plugin before 2.2.9 for WordPress. The unprotected AJAX'
                + ', wp_ajax_accordions_ajax_import_json action allowed any authenticated user with Subscriber or higher permissions the ability to'
                + 'import a new accordion and inject malicious JavaScript as part of the accordion.',
              },
            ],
          },
          problemtype: {
            problemtype_data: [
              {
                description: [
                  {
                    lang: 'eng',
                    value: 'n/a',
                  },
                ],
              },
            ],
          },
          references: {
            reference_data: [
              {
                url: 'https://www.wordfence.com/blog/2020/04/vulnerability-patched-in-accordion-plugin/',
                refsource: 'MISC',
                name: 'https://www.wordfence.com/blog/2020/04/vulnerability-patched-in-accordion-plugin/',
              },
              {
                url: 'https://wordpress.org/plugins/accordions/#developers',
                refsource: 'MISC',
                name: 'https://wordpress.org/plugins/accordions/#developers',
              },
            ],
          },
          impact: {
            cvss: {
              attackComplexity: 'LOW',
              attackVector: 'NETWORK',
              availabilityImpact: 'NONE',
              confidentialityImpact: 'LOW',
              integrityImpact: 'LOW',
              privilegesRequired: 'LOW',
              scope: 'CHANGED',
              userInteraction: 'REQUIRED',
              vectorString: 'CVSS:3.0/AC:L/AV:N/A:N/C:L/I:L/PR:L/S:C/UI:R',
              version: '3.0',
            },
          },
        },
        {
          CVE_data_meta: {
            ASSIGNER: 'cve@mitre.org',
            ID: 'CVE-2019-9978',
            STATE: 'PUBLIC',
            UPDATED: '2020-01-01 (dummy data)',
          },
          affects: {
            vendor: {
              vendor_data: [
                {
                  product: {
                    product_data: [
                      {
                        product_name: 'Social warfare plugins',
                        version: {
                          version_data: [
                            {
                              version_value: '0.1',
                            },
                          ],
                        },
                      },
                    ],
                  },
                  vendor_name: 'WordPress (dummy data)',
                },
                {
                  product: {
                    product_data: [
                      {
                        product_name: 'Warfare plugins',
                        version: {
                          version_data: [
                            {
                              version_value: '0.2',
                              version_affected: '0.2.2, 0.2.3',
                            },
                            {
                              version_value: '1.0',
                              version_affected: '1.0.1-5',
                            },
                          ],
                        },
                      },
                    ],
                  },
                  vendor_name: 'WP (dummy data)',
                },
              ],
            },
          },
          data_format: 'MITRE',
          data_type: 'CVE',
          data_version: '4.0',
          description: {
            description_data: [
              {
                lang: 'eng',
                value: 'The social-warfare plugin before 3.5.3 for WordPress has stored XSS via the wp-admin/admin-post.php?swp_debug=load_options'
                + 'swp_url parameter, as exploited in the wild in March 2019. This affects Social Warfare and Social Warfare Pro.',
              },
            ],
          },
          problemtype: {
            problemtype_data: [
              {
                description: [
                  {
                    lang: 'eng',
                    value: 'Information Disclosure (dummy data)',
                  },
                  {
                    lang: 'eng',
                    value: 'n/a',
                  },
                ],
              },
            ],
          },
          references: {
            reference_data: [
              {
                refsource: 'MISC',
                name: 'https://wpvulndb.com/vulnerabilities/9238',
                url: 'https://wpvulndb.com/vulnerabilities/9238',
              },
              {
                url: 'https://www.cybersecurity-help.cz/vdb/SB2019032105',
                refsource: 'MISC',
                name: 'https://www.cybersecurity-help.cz/vdb/SB2019032105',
              },
              {
                url: 'https://blog.sucuri.net/2019/03/zero-day-stored-xss-in-social-warfare.html',
                refsource: 'MISC',
                name: 'https://blog.sucuri.net/2019/03/zero-day-stored-xss-in-social-warfare.html',
              },
              {
                url: 'https://www.wordfence.com/blog/2019/03/unpatched-zero-day-vulnerability-in-social-warfare-plugin-exploited-in-the-wild/',
                refsource: 'MISC',
                name: 'https://www.wordfence.com/blog/2019/03/unpatched-zero-day-vulnerability-in-social-warfare-plugin-exploited-in-the-wild/',
              },
              {
                url: 'https://www.pluginvulnerabilities.com/2019/03/21/full-disclosure-of-settings-change-persistent-cross-site-scripting-xss-'
                + 'vulnerability-in-social-warfare/',
                refsource: 'MISC',
                name: 'https://www.pluginvulnerabilities.com/2019/03/21/full-disclosure-of-settings-change-persistent-cross-site-scripting-xss-'
                + 'vulnerability-in-social-warfare/',
              },
              {
                url: 'https://wordpress.org/plugins/social-warfare/#developers',
                refsource: 'MISC',
                name: 'https://wordpress.org/plugins/social-warfare/#developers',
              },
              {
                url: 'https://twitter.com/warfareplugins/status/1108852747099652099',
                refsource: 'MISC',
                name: 'https://twitter.com/warfareplugins/status/1108852747099652099',
              },
              {
                refsource: 'EXPLOIT-DB',
                name: '46794',
                url: 'https://www.exploit-db.com/exploits/46794/',
              },
              {
                refsource: 'MISC',
                name: 'http://packetstormsecurity.com/files/152722/Wordpress-Social-Warfare-Remote-Code-Execution.html',
                url: 'http://packetstormsecurity.com/files/152722/Wordpress-Social-Warfare-Remote-Code-Execution.html',
              },
            ],
          },
        },
      ],
    };
  },
  props: {
    inputWidth: {
      type: String,
      required: false,
    },
  },
  created() {
    const fullPathArr = this.$route.fullPath.split('id=');
    if (fullPathArr.length === 2) {
      const cveId = fullPathArr[1];
      this.$store.commit('updateState', { cveId });
      this.cveId = cveId;
      this.validateCveId();
      if (!this.disabled) {
        this.lookupId();
      } else {
        this.$store.commit('updateState', { showHelpText: true });
      }
    } else {
      this.$store.commit('updateState', { showHelpText: true });
    }
  },
  watch: {
    $route(to) {
      if (Object.prototype.hasOwnProperty.call(to.query, 'id')) {
        this.$store.commit('updateState', { cveId: this.$sanitize(to.query.id, { disallowedTagsMode: 'escape' }) });
        this.cveId = to.query.id;
        this.validateCveId();
        if (!this.disabled) {
          this.$store.commit('updateState', { isSearching: false });
          this.lookupId();
        } else {
          this.resetStates();
          this.$store.commit('updateState', { showHelpText: true });
        }
      }
    },
  },
  methods: {
    validateCveId() {
      this.errorMessage = [];

      if (!new RegExp(/^(cve)-\d{4}-\d{4,}$/, 'im').test(this.cveId)) {
        this.errorMessage.push('CVE ID format requirement: CVE-YYYY-NNNN...');
      } else {
        const year = this.cveId.split('-')[1];
        const nextYear = new Date().getFullYear() + 1;

        if (year.length > 0 && (year < 1999 || year > nextYear || !year.match(/^\d{4}$/))) {
          this.errorMessage.push(`YYYY must be a year from 1999 to ${nextYear}`);
        }
      }

      if (this.errorMessage.length === 0) {
        this.disabled = false;
        return false;
      }
      this.disabled = true;
      return true;
    },
    isInitialState() {
      return !!((this.$store.state.cveId.length === 0 && !this.$store.state.error
      && Object.keys(this.$store.state.cveRecord).length === 0 && this.$store.state.cveRecord.constructor === Object));
    },
    resetStates() {
      this.$store.commit('updateState', { error: false });
      this.$store.commit('updateState', { recordData: {} });
      this.$store.commit('updateState', { serverError: false });
      this.$store.commit('updateState', { showHelpText: false });
      this.$store.commit('updateState', { isSearching: false });
    },
    lookupId() {
      const self = this;
      this.resetStates();
      this.$store.commit('updateState', { cveId: this.$sanitize(this.cveId, { disallowedTagsMode: 'escape' }) });
      this.$store.commit('updateState', { isSearching: true });

      // TODO: replace w/ CVE Services endpoint
      const url = `https://api.github.com/search/code?q=${this.$store.state.cveId}+repo:CVEProject/cvelist+extension:json`;

      axios
        .get(url, { timeout: 30000 })
        .then((res) => {
          this.$store.commit('updateState', { showHelpText: false });
          this.$store.commit('updateState', { isSearching: false });

          //* ** PSEUDO CODE STARTS HERE ***//
          // if (res.data.statusCode === 200){

          //   if (!Object.prototype.hasOwnProperty.call(this.data.body, 'error')) {
          //     this.handleCveRecordDisplay();
          //   } else {
          //     // Catching "Parameters were invalid" error which shouldn’t happen bc website code validates the input string and request is
          //     // templated. So ask the user to report the problem so we can troubleshoot?
          //     this.handleServerError();
          //   }

          // } else if (res.data.statusCode === 400) {
          //   // no such ID exists
          //   self.$store.commit('updateState', {error: true});
          // } else {
          //   this.handleServerError();
          // }
          //* ** PSEUDO CODE ENDS HERE ***//

          // TODO: update these cases when service is ready
          if (['CVE-2020-19045', 'CVE-2020-13644', 'CVE-2019-9978'].indexOf(this.$store.state.cveId) > -1) {
            this.handleCveRecordDisplay();
          } else {
            self.$store.commit('updateState', { error: true });
          }
        })
        .catch(() => {
          this.handleServerError();
        })
        .finally(() => {
          const fullPathArr = this.$route.fullPath.split('id=');
          const cveId = fullPathArr[1];
          this.$store.commit('updateState', { showHelpText: false });
          this.$store.commit('updateState', { isSearching: false });

          if (this.$route.name !== 'CVERecord' || ((this.$store.state.cveId.length > 0) && cveId !== this.$store.state.cveId)) {
            this.$router.push(`/CVERecord?id=${this.$store.state.cveId}`);
          }
        });
    },
    formatCveRecord() {
      const keyFields = [
        ['CVE_data_meta', 'UPDATED'],
        ['CVE_data_meta', 'ID'],
        ['CVE_data_meta', 'STATE'],
        ['description', 'description_data'],
        ['problemtype', 'problemtype_data'],
        ['references', 'reference_data'],
        ['affects'],
      ];

      const record = {};
      let i = 0;

      for (i; i < keyFields.length; i += 1) {
        if (Object.prototype.hasOwnProperty.call(this.$store.state.recordData, keyFields[i][0])) {
          if (keyFields[i][0] === 'affects') {
            record.affects = this.getAffectsValues();
          } else {
            const [keyLabel, obj] = this.getNested(keyFields[i]);
            const metaType = ['description_data', 'problemtype_data'];
            const index = metaType.indexOf(keyFields[i][1]);
            if (typeof obj !== 'undefined' && index > -1) {
              let data = [];
              if (obj.length > 0) {
                if (keyLabel === 'description_data') {
                  data = obj.filter((descriptionData) => {
                    if (Object.prototype.hasOwnProperty.call(descriptionData, 'value') && descriptionData.value !== 'n/a') {
                      return descriptionData.value;
                    }
                    return undefined;
                  });
                }

                if (keyLabel === 'problemtype_data') {
                  obj.forEach((problemtypeData) => {
                    data = problemtypeData.description.filter((description) => {
                      if (Object.prototype.hasOwnProperty.call(description, 'value') && description.value !== 'n/a') {
                        return description.value;
                      }
                      return undefined;
                    });
                  });
                }

                if (keyLabel === 'reference_data') {
                  data = obj.filter((reference) => {
                    const ref = {
                      url: undefined,
                      name: undefined,
                    };
                    if (Object.prototype.hasOwnProperty.call(reference, 'url')) {
                      ref.url = reference.value;
                      if (Object.prototype.hasOwnProperty.call(reference, 'name')) {
                        if (reference.namee !== 'n/a' || reference.namee !== '') ref.name = reference.name;
                      }
                    }

                    return ref;
                  });
                }
              }
              record[keyLabel] = data;
            } else {
              record[keyLabel] = obj;
            }
          }
        } else {
          record[keyFields[i]] = undefined;
        }
      }
      this.$store.commit('updateState', { recordData: record });
    },
    getNested(nestedKeysList) {
      let obj = this.$store.state.recordData;
      let i = 0;

      for (i; i < nestedKeysList.length; i += 1) {
        if (!obj || !Object.prototype.hasOwnProperty.call(obj, nestedKeysList[i])) {
          return [nestedKeysList[i], undefined];
        }
        obj = obj[nestedKeysList[i]];
      }
      return [nestedKeysList[i - 1], obj];
    },
    getAffectsValues() {
      const affects = {};

      const vendorData = this.getNested(['affects', 'vendor', 'vendor_data'])[1];
      if (typeof vendorData === 'undefined') {
        return undefined;
      }

      affects.vendors = vendorData.map((vendorObj) => {
        const vendorAndProductInfo = {};
        if (Object.prototype.hasOwnProperty.call(vendorObj, 'product')) {
          if (Object.prototype.hasOwnProperty.call(vendorObj, 'vendor_name')) vendorAndProductInfo.vendor_name = vendorObj.vendor_name;
          const productData = Object.prototype.hasOwnProperty.call(vendorObj.product, 'product_data');
          if (productData) {
            vendorAndProductInfo.products = vendorObj.product.product_data.map((vendor) => {
              const vendorProductData = {};
              if (Object.prototype.hasOwnProperty.call(vendor, 'product_name')) vendorProductData.product_name = vendor.product_name;
              const versionObj = { version_value: [], version_affected: [] };
              if (Object.prototype.hasOwnProperty.call(vendor, 'version')) {
                if (Object.prototype.hasOwnProperty.call(vendor.version, 'version_data')) {
                  vendor.version.version_data.forEach((versionData) => {
                    if (Object.prototype.hasOwnProperty.call(versionData, 'version_value')) versionObj.version_value.push(versionData.version_value);
                    if (Object.prototype.hasOwnProperty.call(versionData, 'version_affected')) {
                      versionObj.version_affected.push(versionData.version_affected);
                    }
                  });

                  vendorProductData.vendor_version = versionObj;
                }
              }
              return vendorProductData;
            });
          }
        }

        return vendorAndProductInfo;
      });
      return affects;
    },
    handleServerError() {
      this.$store.commit('updateState', { showHelpText: false });
      this.$store.commit('updateState', { serverError: true });
      this.$store.commit('updateState', { isSearching: false });
    },
    handleCveRecordDisplay() {
      // TODO update this w/ data from response
      this.$store.commit('updateState', {
        recordData:
        this.records[['CVE-2020-19045', 'CVE-2020-13644', 'CVE-2019-9978'].indexOf(this.$store.state.cveId)],
      });

      // process data to display
      this.formatCveRecord();
    },
  },
});
</script>

<style scoped lang="scss">
@import '../assets/style/globals.scss';
button[disabled]{
  opacity: 0.7 !important;
  background-color: #3d4551;
  color: white;
}

.notification {
  margin: 0 0 2px 0 !important;
  padding: 2px 10px 2px 10px  !important;
}

.field {
  min-width: 400px !important;
}
</style>
